# 指针初解

> 指针使得 C 语言能够更高效地实现对计算机底层硬件的操作，而计算机硬件的操作很大程度上依赖地址，指针便提供了一种对地址操作的方法，在一定意义上，指针是c语言的精髓，所以一定要耐心看完。

指针对于很多c语言初学者来说可能难以理解，一不小心可能被指针的指向关系绕进去，在这里就对指针做一些总结，写一下自己的理解。

## 一. 指针的介绍

在程序中，我们声明一个变量（int a = 1），将数据1存到变量a中，计算机内部会将这个数据存到内存（RAM）中，那么，数据存到某个地方，就会涉及地址。就像你买的快递，快递到了就要存到某个驿站里面放着，你的快递就是一个数据，驿站就是一个变量，这个驿站就要有地址，不然全国这么多驿站你怎么知道你的快递在哪个驿站。

到这里，地址的概念应该有了吧。

现在想想地址（比如0x0000 0001）不也是一个数据吗，那么不也可以用一个变量存地址这个数据？是的，可以，这个变量就是指针，指针它就是存储另一个变量的内存地址的一种数据类型，即指针的内容就是另一个变量的内存地址。

> **指针本身也是一个变量，所以指针变量也有自己的地址，只是它有点特殊，它存放的是另一个变量的地址而已，理解这句话就行。**

前面讲到过指针它是一种**数据类型**，为了方便，我们就规定在这种类型后面加\*号表示该类型指针，有`char型指针（char *`）、`double型指针(double *)`和`int型指针（int *）`等等。

试着敲一下下面一段代码，可以加深对指针的认识：
 ```c
int a = 1;       // 定义一个int型变量
int *p = &a;     // 定义一个int型指针p，&a表示对a取地址，指针p的内容是a的地址
// int  *p;   p = &a;    // 第二行也可以这样写，意思一样
printf("%p\n", &a);      // 打印a的地址
printf("%p\n", p);       // 打印指针p指向的地址
// %p是打印地址（指针地址），是十六进制的形式
 ```

> `C/C++` 中规定了`* 操作符`来从对应指针类型存放的地址中`拿出相应数据`，再定义一个变量int b = \*p，指针p存了a的地址，\*p就是拿出a的值，b的值就变成了1，`*操作`也被称为`解引用`。

## 二. 指针的相关操作（运算）

>  **算数运算：+、-、++、--**

指针的运算是特别容易搞错的，千万不能以为和普通类型（比如int型数据）的运算一样。

**指针的加减运算：**

1.  `指针+1/指针-1`，加/减的是整个指针类型的长度，与其说指针的加减法，我认为不如说成`指针的偏移`更合适，接下来看为什么是偏移，举个非常明显的例子：

```c
char a[5] = {1, 2, 3, 4, 5};  // 定义一个char型数组，这里的a实质上是一个指针，指向这个数组的首元素a[0]的指针
char *p = a;
printf("%d\n", *p);        // 输出1 --> a[0]
printf("%d\n", *(p + 1));  // 输出2 --> a[1]
......
```

看输出的结果就很容易看出规律，p指针指向a[0]，特别注意p+1指针变成指向a[1]，所以\*(p+1)  = a[1] = 2，而不是\*(p+1)  = a[0] + 1 = 2，当然这里两个答案凑巧一样，但是把数组的内容换一下就不会是一样了，如果是改成(\*p) + 1，那么就是(\*p) + 1 = a[0] + 1 = 2，同理可以改成p+2、p+3......

还有试着定义其它类型的数组（比如int型：**int** **a[5] = {1, 2, 3, 4, 5};**），看看是不是这个规律，就可以知道指针加减的是这个指针类型的长度，也就是指针的偏移，还可以尝试定义结构体数组，将会有更深的理解。

减法就不用多说了，理解了指针p+1/p-1，那么指针p++/p--其实是一样的，都是偏移。

## 三. 多级指针

>  **说起多级指针这个东西，曾经大一学c语言的时候，学到二级指针都已经把我给绕晕了，如果当时你给我写个int \*\*\*\*\*\*\*\*p出来，我估计直接崩溃到放弃。**

我们先来说说二级指针吧！前面有讲到，指针也是一种数据类型，是一种变量，也有自己的地址，所以既然有地址，而指针就是存放另一个变量的地址的呀，那为什么不能再用一个指针存放这个指针的地址呢，对吧！所以就有了二级指针，就是**指向指针的指针**。

ok！来点生活上的东西，快递柜大家都用过吧，快递小哥给你发一个取件码你就能拿到快递。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/Wc8GWqUU6cfl8Wb9MK3bevHdgo97lmPchiaFFvs9vlGicLBGU94V9K4RIqcK4rPASfmGKrmOfHfKLju0whPPvnEw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

这里的每一个柜子就是一块内存，取件码就是地址，柜子里的快递就是存储在内存的内容/数据。

假如快递小哥把你的快递放到"058柜子"，给你发取件码，那么你输入取件码就可以取到快递。

![图片](https://mmbiz.qpic.cn/mmbiz_png/Wc8GWqUU6cfl8Wb9MK3bevHdgo97lmPcvcUoBFTDVKCTNics0SaHib9dVE3HYo6J6AUe3seF6xx3G4vqjQbYribiaA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

如果快递小哥逗你一下，故意给你发"057柜子"的取件码，然后在"057柜子"放一张纸条，上面写:快递在058柜子，这时候你肯定是按照纸条从"058柜子"里就可以拿到快递。

这里的"057柜子"就是指针，指针里面存放另一个变量（058柜子）的地址。

![图片](https://mmbiz.qpic.cn/mmbiz_png/Wc8GWqUU6cfl8Wb9MK3bevHdgo97lmPcqiauruKWYxedRNLKzoC46MSp05l89ocpqwPicIiclQxMsnhFY4ibprMvSg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

如果快递小哥给你发"056柜子"的取件码，在"056柜子"里放一张纸条写：快递在"057柜子"里，又在"057柜子"里放一张纸条写：快递在"058柜子"里。

这里的"056柜子"就是二级指针，"057柜子"就是指针，"058柜子"就是指针存放的另一个变量。

![图片](https://mmbiz.qpic.cn/mmbiz_png/Wc8GWqUU6cfl8Wb9MK3bevHdgo97lmPcrQLHXEgYUzIfgzlNkExVwpUb3r8Tx2uKFucdmyy5iaAt4ZSAnrkxv4w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

现在明白了二级指针吧，那么，N级指针也就那样，也就是**指向指针的指针的指针的指针的指针........**，是不是非常简单！

```c
int a = 1;
int *p = &a;
int **pp = &p;     // 二级指针pp存放指针p的地址，即二级指针pp指向指针p
int ***ppp = &pp;  // 三级指针ppp存放二级指针pp的地址，即三级指针ppp指向二级指针pp
......
```

总之，如果一个内存如果存放的是另一个变量的地址，那么就叫指针。一块内存要么存放实际内容/数据，要么存放的是另一个变量的地址，确实是刚刚所说的非常简单。

**【总结两点】：**

**1. 指针本身也是一个变量，也有自己的地址，需要内存存储。** 
**2. 指针存放的是所指向的变量的地址，这个所指向的变量也可以是一个指针。**

**【特别注意】：面试可能被问到指针的大小**

**1. 指针的大小跟指针是什么类型的没有任何关系。**
**2. 在32为系统系统中，所有的指针大小都是4个字节，原因是32系统上所有变量的地址都是32位的，而指针用来存地址的。**

最后，大家要明白一个概念，其实并没有什么多级指针这种东西，多级指针就是个指针，称为多级指针是为了我们方便表达而取的逻辑名称。

## 四. 多维数组

**二维数组其实和二级指针有着相似的理解方法：**

**比如a\[3\]\[2\]，把它理解成一个一维数组来看待，这个一维数组里面有三个元素，只是这个一维数组有点特殊，它的每个元素又是一个一维数组而已。**

懂了上面这段话，二维数组就很好理解。

前面我们已经知道一维数组a[3]中，a实质上是一个指针，指向这个数组首元素a[0]：

```c
int a[3] = {1, 2, 3};
// a[0]  -->  *a
printf("%d\n", *a);       // 打印 1  -->  a[0] 的值
// a[1]  -->  *(a + 1)
printf("%d\n", *(a + 1)); // 打印 2  -->  a[1] 的值
// a[2]  -->  *(a + 2)
printf("%d\n", *(a + 2)); // 打印 3  -->  a[2] 的值
```

那么，二维数组a\[3]\[2]当成一维数组看是不是可以得出：

```c
int a[3][2] = {{1, 2}, {3, 4}, {5, 6}};
// a[0][0]  -->  (*a)[0]
printf("%d\n", (*a)[0]);       // 打印 1  -->  a[0][0] 的值
// a[1][0]  -->  (*(a + 1))[0]
printf("%d\n", (*(a + 1))[0]); // 打印 3  -->  a[1][0] 的值
// a[2][0]  -->  (*(a + 2))[0]
printf("%d\n", (*(a + 2))[0]); // 打印 5  -->  a[2][0] 的值
// a[2][1]  -->  (*(a + 2))[1]
printf("%d\n", (*(a + 2))[1]); // 打印 6  -->  a[2][1] 的值
// ..... 二维数组其它元素类似都可以输出
```

**``结论一：a[m][n]  等价于 （*(a + m)[n]-->就是一个数组指针(后面会提到）``**

基于前面两种指针和数组的变换，可以继续得出：

```c
int a[3][2] = {{1, 2}, {3, 4}, {5, 6}};
// a[0][0]  -->  (*a)[0]  -->  *(*a + 0)  -->  把 *a 当成整体
printf("%d\n", *(*a));           // 打印 1  -->  a[0][0] 的值
// a[1][0]  -->  (*(a + 1))[0]  -->  *(*(a + 1) + 0)
printf("%d\n", *(*(a + 1)));     // 打印 3  -->  a[1][0] 的值
// a[2][0]  -->  (*(a + 2))[0]  -->  *(*(a + 2) + 0)
printf("%d\n", *(*(a + 2)));     // 打印 5  -->  a[2][0] 的值
// a[2][1]  -->  (*(a + 2))[1]  -->  *(*(a + 2) + 1)
printf("%d\n", *(*(a + 2) + 1)); // 打印 6  -->  a[2][1] 的值
// ..... 二维数组其它元素类似都可以输出
```
**``结论二：a[m][n] 等价于 *(*(a + m) + n)``**

## 五. 数组指针与指针数组

1. **数组指针：**指针在后，说明它就是个指针，所以数组指针指向的是数组，相当于一次声明了一个指针。从前面就已经知道，二维数组a\[3]\[2]中，a实质上就是一个**数组指针**。

**公式：**

**指向的那个数组的元素类型  (\*指针名字)\[指向的数组的元素个数]**

2. **指针数组：**数组在后，说明它就是个数组。字符数组是什么？就是存放字符的数组，那么指针数组就是存放指针类型的数组，相当于一次声明了多个指针。

**公式：**

**数组元素的类型  数组名字\[数组元素个数]**

```c
char *a[3] = {"red", "green", "blue"};
char **pp = a;    //定义二级指针pp, a本质上相当于二级指针
printf("%s\n", pp[0]);    // 打印 red
printf("%s\n", pp[1]);    // 打印 green
printf("%s\n", pp[2]);    // 打印 blue
```

**直观上区分数组指针和指针数组的方法：**

> 由于数组指针的 `[] `比 `* `的优先级高，所以数组指针的指针加括号，所以看看指针有没有用圆括号括起来，就可以区分开。

## 六. 其它

关于指针想写的内容还有很多，其实这只是开了个头，比如：野指针、函数指针、函数参数传递方式、`const` 修饰指针、动态内存分配: `malloc` 和 `free`、堆, 栈、内存泄露......，以后再慢慢补齐。

指针在链表使用的比较多，多写一些链表的操作会对指针理解很有帮助，链表节点的增加、删除、修改、查找，单向链表、双向链表、双向循环链表、内核链表等等。