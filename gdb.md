# GDB使用详解

## 1. 概述

 GDB 全称“GNU symbolic debugger”，从名称上不难看出，它诞生于 GNU 计划（同时诞生的还有 GCC、Emacs 等），是 Linux 下常用的程序调试器。发展至今，GDB 已经迭代了诸多个版本，当下的 GDB 支持调试多种编程语言编写的程序，包括 C、C++、Go、Objective-C、OpenCL、Ada 等。实际场景中，GDB 更常用来调试 C 和 C++ 程序。一般来说，GDB主要帮助我们完成以下四个方面的功能：

1. 启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。
2. 在某个指定的地方或条件下暂停程序。
3. 当程序被停住时，可以检查此时你的程序中所发生的事。
4. 在程序执行过程中修改程序中的变量或条件，将一个bug产生的影响修正从而测试其他bug。

使用GDB调试程序，有以下两点需要注意：

1. 要使用GDB调试某个程序，该程序编译时必须加上编译选项 **-g**，否则该程序是不包含调试信息的；
2. GCC编译器支持 **-O** 和 **-g** 一起参与编译。GCC编译过程对进行优化的程度可分为5个等级，分别为 ：

- **-O/-O0**： 不做任何优化，这是默认的编译选项 ；
- **-O1**：使用能减少目标文件大小以及执行时间并且不会使编译时间明显增加的优化。 该模式在编译大型程序的时候会花费更多的时间和内存。在 -O1下：编译会尝试减少代 码体积和代码运行时间，但是并不执行会花费大量时间的优化操作。
- **-O2**：包含 -O1的优化并增加了不需要在目标文件大小和执行速度上进行折衷的优化。 GCC执行几乎所有支持的操作但不包括空间和速度之间权衡的优化，编译器不执行循环 展开以及函数内联。这是推荐的优化等级，除非你有特殊的需求。 -O2会比 -O1启用多 一些标记。与 -O1比较该优化 -O2将会花费更多的编译时间当然也会生成性能更好的代 码。
- **-O3**：打开所有 -O2的优化选项并且增加 -finline-functions, -funswitch-loops,-fpredictive-commoning, -fgcse-after-reload and -ftree-vectorize优化选项。这是最高最危险 的优化等级。用这个选项会延长编译代码的时间，并且在使用 gcc4.x的系统里不应全局 启用。自从 3.x版本以来 gcc的行为已经有了极大地改变。在 3.x，，-O3生成的代码也只 是比 -O2快一点点而已，而 gcc4.x中还未必更快。用 -O3来编译所有的 软件包将产生更 大体积更耗内存的二进制文件，大大增加编译失败的机会或不可预知的程序行为（包括 错误）。这样做将得不偿失，记住过犹不及。在 gcc 4.x.中使用 -O3是不推荐的。
- **-Os**：专门优化目标文件大小 ,执行所有的不增加目标文件大小的 -O2优化选项。同时 -Os还会执行更加优化程序空间的选项。这对于磁盘空间极其紧张或者 CPU缓存较小的 机器非常有用。但也可能产生些许问题，因此软件树中的大部分 ebuild都过滤掉这个等 级的优化。使用 -Os是不推荐的。

## 2. 启用GDB调试

GDB调试主要有三种方式：

1. 直接调试目标程序：gdb ./hello_server
2. 附加进程id：gdb attach pid
3. 调试core文件：gdb filename corename

## 3. 退出GDB

- 可以用命令：**q（quit的缩写）或者 Ctr + d** 退出GDB。
- 如果GDB attach某个进程，退出GDB之前要用命令 **detach** 解除附加进程。

  4. 常用命令

|  命令名称 | 命令缩写  |  命令说明   |
| :---------: | :-------: | :---------------------------------: |
|     run     |     r     | 运行一个待调试的程序 |
|  continue   |     c     | 让暂停的程序继续运行|
|    next     |     n     | 运行到下一行  |
|    step     |     s     | 单步执行，遇到函数会进入   |
|    until    |     u     |    运行到指定行停下来   |
|   finish    |    fi     |      结束当前调用函数，回到上一层调用函数处      |
|   return    |  return   | 结束当前调用函数并返回指定值，到上一层函数调用处 |
|    jump     |     j     |        将当前程序执行流跳转到指定行或地址        |
|    print    |     p     |      打印变量或寄存器值        |
|  backtrace  |    bt     |      查看当前线程的调用堆栈     |
|    frame    |     f     |    切换到当前调用线程的指定堆栈  |
|   thread    |  thread   |     切换到指定线程      |
|    break    |     b     |   添加断点      |
|   tbreak    |    tb     |  添加临时断点     |
|   delete    |     d     |    删除断点       |
|   enable    |  enable   |    启用某个断点    |
|   disable   |  disable  |   禁用某个断点     |
|    watch    |   watch   |     监视某一个变量或内存地址的值是否发生变化     |
|    list     |     l     |         显示源码          |
|    info     |     i     |     查看断点 / 线程等信息        |
|    ptype    |   ptype   |       查看变量类型   |
| disassemble |    dis    |     查看汇编代码     |
|  set args   | set args  |  设置程序启动命令行参数   |
|  show args  | show args |   查看设置的命令行参数    |

## 常用命令举例

\*启动gdb 
\$gdb 
这样可以和gdb进行交互了。 

\*启动gdb，并且分屏显示源代码： 
\$gdb -tui 
这样,使用了'-tui'选项，启动可以直接将屏幕分成两个部分，上面显示源代码，比用list方便多了。这时候使用上下方向键可以查看源代码,想要命令行使用上下键就用[Ctrl]n和[Ctrl]p. 

\*启动gdb调试指定程序app： 
\$gdb app 
这样就在启动gdb之后直接载入了app可执行程序，需要注意的是，载入的app程序必须在编译的时候有gdb调试选项，例如'gcc -g app app.c',注意，如果修改了程序的源代码，但是没有编译，那么在gdb中显示的会是改动后的源代码，但是运行的是改动前的程序，这样会导致跟踪错乱的。 

\*启动程序之后，再用gdb调试： 
$gdb <program> <PID> 
这里，<program>是程序的可执行文件名，<PID>是要调试程序的PID.如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。 

\*启动程序之后，再启动gdb调试： 
$gdb <PID> 
这里，程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID,<PID>是要调试程序的PID.这样gdb就附加到程序上了，但是现在还没法查看源代码,用file命令指明可执行文件就可以显示源代码了。 


\*\*启动gdb之后的交互命令： 
交互命令支持[Tab]补全。 

\*显示帮助信息： 
(gdb) help 

\*载入指定的程序： 
(gdb) file app 
这样在gdb中载入想要调试的可执行程序app。如果刚开始运行gdb而不是用gdb app启动的话可以这样载入app程序，当然编译app的时候要加入-g调试选项。 

\*重新运行调试的程序： 
(gdb) run 
要想运行准备调试的程序，可使用run命令，在它后面可以跟随发给该程序的任何参数，包括标准输入和标准输出说明符(<和> )和shell通配符（*、？、[、]）在内。 

\*修改发送给程序的参数： 
(gdb) set args no 
这里，假设我使用"r yes"设置程序启动参数为yes，那么这里的set args会设置参数argv[1]为no。 

\*显示缺省的参数列表： 
(gdb) show args 

\*列出指定区域(n1到n2之间)的代码： 
(gdb) list n1 n2 
这样,list可以简写为l,将会显示n1行和n2行之间的代码，如果使用-tui启动gdb，将会在相应的位置显示。如果没有n1和n2参数，那么就会默认显示当前行和之后的10行，再执行又下滚10行。另外，list还可以接函数名。 
一般来说在list后面可以跟以下这们的参数： 
\<linenum>   行号。 
\<+offset>   当前行号的正偏移量。 
\<-offset>   当前行号的负偏移量。 
\<filename:linenum>  哪个文件的哪一行。 
\<function>  函数名。 
\<filename:function> 哪个文件中的哪个函数。 
\<\*address>  程序运行时的语句在内存中的地址。 

\*执行下一步： 
(gdb) next 
这样，执行一行代码，如果是函数也会跳过函数。这个命令可以简化为n. 

\*执行N次下一步： 
(gdb) next N 

\*执行上次执行的命令： 
(gdb) [Enter] 
这里，直接输入回车就会执行上次的命令了。 

\*单步进入： 
(gdb) step 
这样，也会执行一行代码，不过如果遇到函数的话就会进入函数的内部，再一行一行的执行。 

\*执行完当前函数返回到调用它的函数： 
(gdb) finish 
这里，运行程序，直到当前函数运行完毕返回再停止。例如进入的单步执行如果已经进入了某函数，而想退出该函数返回到它的调用函数中，可使用命令finish. 

\*指定程序直到退出当前循环体： 
(gdb) until 
或(gdb) u 
这里，发现需要把光标停止在循环的头部，然后输入u这样就自动执行全部的循环了。 

\*跳转执行程序到第5行： 
(gdb) jump 5 
这里，可以简写为"j 5"需要注意的是，跳转到第5行执行完毕之后，如果后面没有断点则继续执行，而并不是停在那里了。 
另外，跳转不会改变当前的堆栈内容，所以跳到别的函数中就会有奇怪的现象，因此最好跳转在一个函数内部进行,跳转的参数也可以是程序代码行的地址,函数名等等类似list。 

\*强制返回当前函数: 
(gdb) return 
这样，将会忽略当前函数还没有执行完毕的语句，强制返回。return后面可以接一个表达式，表达式的返回值就是函数的返回值。 

\*强制调用函数： 
(gdb) call \<expr> 
这里,\<expr>可以是一个函数，这样就会返回函数的返回值，如果函数的返回类型是void那么就不会打印函数的返回值,但是实践发现，函数运行过程中的打印语句还是没有被打印出来。 

\*强制调用函数2： 
(gdb) print \<expr> 
这里，print和call的功能类似，不同的是，如果函数的返回值是void那么call不会打印返回值，但是print还是会打印出函数的返回值并且存放到历史记录中。 

\*在当前的文件中某一行（假设为6）设定断点： 
(gdb) break 6 

\*设置条件断点： 
(gdb) break 46 if testsize==100 
这里，如果testsize==100就在46行处断点。 

\*检测表达式变化则停住： 
(gdb) watch i != 10 
这里，i != 10这个表达式一旦变化，则停住。watch \<expr> 为表达式（变量）expr设置一个观察点。一量表达式值有变化时，马上停住程序(也是一种断点)。 

\*在当前的文件中为某一函数(假设为func)处设定断点： 
(gdb) break func 

\*给指定文件（fileName）的某个行（N）处设置断点： 
(gdb) break fileName:N 
这里，给某文件中的函数设置断点是同理的。 

\*显示当前gdb断点信息： 
(gdb) info breakpoints 
这里，可以简写为info break.会显示当前所有的断点，断点号，断点位置等等。 

\*删除N号断点： 
(gdb) delete N 

\*删除所有断点： 
(gdb) delete 

\*清除行N上面的所有断点： 
(gdb) clear N 


\*继续运行程序直接运行到下一个断点： 
(gdb) continue 
这里，如果没有断点就一直运行。 

\*显示当前调用函数堆栈中的函数： 
(gdb) backtrace 
命令产生一张列表，包含着从最近的过程开始的所有有效过程和调用这些过程的参数。当然，这里也会显示出当前运行到了哪里(文件，行)。 

\*查看当前调试程序的语言环境： 
(gdb) show language 
这里，如果gdb不能识别你所调试的程序，那么默认是c语言。 

\*查看当前函数的程序语言： 
(gdb) info frame 

\*显示当前的调试源文件： 
(gdb) info source 
这样会显示当前所在的源代码文件信息,例如文件名称，程序语言等。 

\*手动设置当前的程序语言为c++: 
(gdb) set language c++ 
这里，如果gdb没有检测出你的程序语言，你可以这样设置。 

\*查看可以设置的程序语言： 
(gdb) set language 
这里，使用没有参数的set language可以查看gdb中可以设置的程序语言。 

\*终止一个正在调试的程序： 
(gdb) kill 
这里，输入kill就会终止正在调试的程序了。 

\*print显示变量(var)值： 
(gdb) print var 
这里，print可以简写为p,print 是gdb的一个功能很强的命令，利用它可以显示被调试的语言中任何有效的表达式。表达式除了包含你程序中的变量外，还可以包含函数调用,复杂数据结构和历史等等。 

\*用16进制显示(var)值： 
(gdb) print /x var 
这里可以知道，print可以指定显示的格式，这里用'/x'表示16进制的格式。 
可以支持的变量显示格式有： 
x  按十六进制格式显示变量。 
d  按十进制格式显示变量。 
u  按十六进制格式显示无符号整型。 
o  按八进制格式显示变量。 
t  按二进制格式显示变量。 
a  按十六进制格式显示变量。 
c  按字符格式显示变量。 
f  按浮点数格式显示变量。 


\*如果a是一个数组，10个元素，如果要显示则： 
(gdb) print \*a@10 
这样，会显示10个元素，无论a是double或者是int的都会正确地显示10个元素。 

\*修改运行时候的变量值： 
(gdb) print x=4 
这里，x=4是C/C++的语法，意为把变量x值改为4，如果你当前调试的语言是Pascal，那么你可以使用Pascal的语法：x:=4。 

\*显示一个变量var的类型： 
(gdb) whatis var 

\*以更详细的方式显示变量var的类型： 
(gdb) ptype var 
这里，会打印出var的结构定义。 